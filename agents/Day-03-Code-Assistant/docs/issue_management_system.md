# Issue Management System

This document provides implementation details for the Issue Management System of the Repository Analysis and Issue Creation Agent. This component is responsible for creating, formatting, and submitting GitHub issues based on the AI analysis findings.

## Table of Contents

1. [Overview](#overview)
2. [Key Responsibilities](#key-responsibilities)
3. [Implementation Details](#implementation-details)
4. [Code Examples](#code-examples)
5. [Best Practices](#best-practices)
6. [Integration Points](#integration-points)

## Overview

The Issue Management System transforms the findings from the AI Analysis Coordinator into well-structured GitHub issues. It handles the formatting of issue content, applies appropriate labels and metadata, and manages the creation process through the GitHub API. This component ensures that the insights generated by the AI are effectively communicated to development teams through their existing workflow tools.

## Key Responsibilities

- **Issue Formatting**: Format findings into clear, actionable GitHub issues
- **Template Management**: Apply and customize issue templates
- **Label Management**: Apply appropriate labels based on issue type and priority
- **GitHub API Integration**: Create and update issues via the GitHub API
- **Duplicate Detection**: Prevent creation of duplicate issues
- **Issue Tracking**: Track created issues for future reference

## Implementation Details

### Issue Formatting

First, we need to format the findings into well-structured GitHub issues:

```javascript
class IssueFormatter {
  formatFileIssue(finding, filePath) {
    const title = this.createIssueTitle(finding, filePath);
    const body = this.createFileIssueBody(finding, filePath);
    const labels = this.determineLabels(finding);
    
    return {
      title,
      body,
      labels
    };
  }
  
  formatRepositoryIssue(finding) {
    const title = this.createIssueTitle(finding);
    const body = this.createRepositoryIssueBody(finding);
    const labels = this.determineLabels(finding);
    
    return {
      title,
      body,
      labels
    };
  }
  
  createIssueTitle(finding, filePath = null) {
    // Create a concise, descriptive title
    let title = finding.title;
    
    // Add file path for file-specific issues
    if (filePath) {
      const shortPath = this.shortenPath(filePath);
      title = `[${shortPath}] ${title}`;
    }
    
    // Add priority prefix for high-priority issues
    if (finding.priority === 'Critical' || finding.priority === 'High') {
      title = `[${finding.priority}] ${title}`;
    }
    
    return title;
  }
  
  shortenPath(filePath) {
    // Shorten file path to make it more readable
    const parts = filePath.split('/');
    if (parts.length <= 2) return filePath;
    
    // Keep the last two parts
    return `.../${parts[parts.length - 2]}/${parts[parts.length - 1]}`;
  }
  
  createFileIssueBody(finding, filePath) {
    // Create a detailed issue body for file-specific issues
    return `
## Issue Description

${finding.description}

## Location

File: \`${filePath}\`
${finding.location ? `Location: ${finding.location}` : ''}

## Suggested Solution

${finding.suggestion}

## Priority

**${finding.priority}**

---
*This issue was automatically generated by the Repository Analysis Agent.*
    `.trim();
  }
  
  createRepositoryIssueBody(finding) {
    // Create a detailed issue body for repository-level issues
    return `
## Issue Description

${finding.description}

## Affected Area

${finding.area}

## Suggested Solution

${finding.suggestion}

## Priority

**${finding.priority}**

---
*This issue was automatically generated by the Repository Analysis Agent.*
    `.trim();
  }
  
  determineLabels(finding) {
    // Determine appropriate labels based on the finding
    const labels = ['ai-generated'];
    
    // Add priority label
    labels.push(`priority:${finding.priority.toLowerCase()}`);
    
    // Add type label based on finding content
    if (finding.title.toLowerCase().includes('bug') || finding.description.toLowerCase().includes('bug')) {
      labels.push('bug');
    } else if (finding.title.toLowerCase().includes('enhancement') || finding.description.toLowerCase().includes('enhancement')) {
      labels.push('enhancement');
    } else if (finding.title.toLowerCase().includes('documentation') || finding.description.toLowerCase().includes('documentation')) {
      labels.push('documentation');
    } else if (finding.title.toLowerCase().includes('security') || finding.description.toLowerCase().includes('security')) {
      labels.push('security');
    } else if (finding.title.toLowerCase().includes('performance') || finding.description.toLowerCase().includes('performance')) {
      labels.push('performance');
    } else {
      labels.push('technical-debt');
    }
    
    return labels;
  }
}
```

### GitHub API Integration

Next, we need to implement the GitHub API integration:

```javascript
const { Octokit } = require('@octokit/rest');

class GitHubIssueCreator {
  constructor(config) {
    this.config = config;
    this.octokit = this.initializeOctokit(config.github);
    this.issueFormatter = new IssueFormatter();
  }
  
  initializeOctokit(config) {
    if (!config || !config.token) {
      console.warn('GitHub token not provided');
      return null;
    }
    
    return new Octokit({
      auth: config.token
    });
  }
  
  async createIssue(owner, repo, issueData) {
    if (!this.octokit) {
      return { success: false, error: 'GitHub API not initialized' };
    }
    
    try {
      // Check for duplicate issues first
      const isDuplicate = await this.checkForDuplicateIssue(owner, repo, issueData.title);
      if (isDuplicate) {
        return {
          success: false,
          error: 'Duplicate issue detected',
          isDuplicate: true
        };
      }
      
      // Create the issue
      const response = await this.octokit.issues.create({
        owner,
        repo,
        title: issueData.title,
        body: issueData.body,
        labels: issueData.labels
      });
      
      return {
        success: true,
        issueNumber: response.data.number,
        issueUrl: response.data.html_url
      };
    } catch (error) {
      console.error('Error creating GitHub issue:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  async checkForDuplicateIssue(owner, repo, title) {
    try {
      // Search for open issues with similar titles
      const response = await this.octokit.search.issuesAndPullRequests({
        q: `repo:${owner}/${repo} is:issue is:open "${title.substring(0, 50)}"`
      });
      
      // Check if any issues have very similar titles
      return response.data.items.some(issue => {
        const similarity = this.calculateTitleSimilarity(issue.title, title);
        return similarity > 0.8; // 80% similarity threshold
      });
    } catch (error) {
      console.error('Error checking for duplicate issues:', error.message);
      return false; // Assume no duplicates if check fails
    }
  }
  
  calculateTitleSimilarity(title1, title2) {
    // Simple Jaccard similarity for titles
    const words1 = new Set(title1.toLowerCase().split(/\s+/));
    const words2 = new Set(title2.toLowerCase().split(/\s+/));
    
    const intersection = new Set([...words1].filter(word => words2.has(word)));
    const union = new Set([...words1, ...words2]);
    
    return intersection.size / union.size;
  }
  
  async createIssueFromFinding(owner, repo, finding, filePath = null) {
    // Format the finding into an issue
    const issueData = filePath
      ? this.issueFormatter.formatFileIssue(finding, filePath)
      : this.issueFormatter.formatRepositoryIssue(finding);
    
    // Create the issue
    return await this.createIssue(owner, repo, issueData);
  }
  
  async createIssuesFromFindings(owner, repo, findings) {
    const results = [];
    
    for (const finding of findings) {
      const filePath = finding.source === 'file' ? finding.filePath : null;
      const result = await this.createIssueFromFinding(owner, repo, finding, filePath);
      
      results.push({
        finding,
        result
      });
      
      // Add a small delay between requests to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    return results;
  }
}
```

### Issue Tracking

Finally, we need to implement issue tracking to maintain a record of created issues:

```javascript
class IssueTracker {
  constructor(storageManager) {
    this.storageManager = storageManager;
  }
  
  async recordCreatedIssue(repositoryId, issueData) {
    // Get existing issues for this repository
    const existingIssues = await this.getRepositoryIssues(repositoryId);
    
    // Add the new issue
    existingIssues.push({
      issueNumber: issueData.issueNumber,
      issueUrl: issueData.issueUrl,
      title: issueData.title,
      createdAt: new Date().toISOString(),
      labels: issueData.labels
    });
    
    // Save updated issues
    await this.storageManager.saveData(`issues/${repositoryId}`, existingIssues);
    
    return true;
  }
  
  async getRepositoryIssues(repositoryId) {
    try {
      return await this.storageManager.loadData(`issues/${repositoryId}`) || [];
    } catch (error) {
      console.error('Error loading repository issues:', error.message);
      return [];
    }
  }
  
  async getIssueStats() {
    // Get all repository IDs
    const repositoryIds = await this.storageManager.listDataKeys('issues');
    
    // Collect stats for each repository
    const stats = {
      totalIssues: 0,
      issuesByRepository: {},
      issuesByPriority: {
        Critical: 0,
        High: 0,
        Medium: 0,
        Low: 0
      },
      issuesByLabel: {}
    };
    
    // Process each repository
    for (const repoId of repositoryIds) {
      const issues = await this.getRepositoryIssues(repoId);
      
      stats.totalIssues += issues.length;
      stats.issuesByRepository[repoId] = issues.length;
      
      // Count by priority and label
      issues.forEach(issue => {
        // Count by priority
        issue.labels.forEach(label => {
          if (label.startsWith('priority:')) {
            const priority = label.replace('priority:', '');
            const normalizedPriority = priority.charAt(0).toUpperCase() + priority.slice(1);
            stats.issuesByPriority[normalizedPriority] = (stats.issuesByPriority[normalizedPriority] || 0) + 1;
          }
          
          // Count by label
          stats.issuesByLabel[label] = (stats.issuesByLabel[label] || 0) + 1;
        });
      });
    }
    
    return stats;
  }
}
```

## Code Examples

### Complete Issue Management System

Here's a more complete example of an Issue Management System that combines the above components:

```javascript
// issueManagementSystem.js
const { Octokit } = require('@octokit/rest');
const IssueFormatter = require('./IssueFormatter');
const IssueTracker = require('./IssueTracker');

class IssueManagementSystem {
  constructor(config, storageManager) {
    this.config = config;
    this.octokit = this.initializeOctokit(config.github);
    this.issueFormatter = new IssueFormatter();
    this.issueTracker = new IssueTracker(storageManager);
  }
  
  initializeOctokit(config) {
    if (!config || !config.token) {
      console.warn('GitHub token not provided');
      return null;
    }
    
    return new Octokit({
      auth: config.token
    });
  }
  
  async createIssuesFromFindings(owner, repo, findings, options = {}) {
    if (!this.octokit) {
      return { success: false, error: 'GitHub API not initialized' };
    }
    
    const repositoryId = `${owner}/${repo}`;
    const results = [];
    let createdCount = 0;
    let duplicateCount = 0;
    let errorCount = 0;
    
    // Apply limit if specified
    const limitedFindings = options.limit ? findings.slice(0, options.limit) : findings;
    
    for (const finding of limitedFindings) {
      // Skip low priority issues if configured to do so
      if (options.skipLowPriority && finding.priority === 'Low') {
        continue;
      }
      
      // Format the finding into an issue
      const filePath = finding.source === 'file' ? finding.filePath : null;
      const issueData = filePath
        ? this.issueFormatter.formatFileIssue(finding, filePath)
        : this.issueFormatter.formatRepositoryIssue(finding);
      
      try {
        // Check for duplicate issues
        const isDuplicate = await this.checkForDuplicateIssue(owner, repo, issueData.title);
        
        if (isDuplicate) {
          results.push({
            finding,
            success: false,
            isDuplicate: true
          });
          duplicateCount++;
          continue;
        }
        
        // Create the issue
        const response = await this.octokit.issues.create({
          owner,
          repo,
          title: issueData.title,
          body: issueData.body,
          labels: issueData.labels
        });
        
        // Record the created issue
        await this.issueTracker.recordCreatedIssue(repositoryId, {
          issueNumber: response.data.number,
          issueUrl: response.data.html_url,
          title: issueData.title,
          labels: issueData.labels
        });
        
        results.push({
          finding,
          success: true,
          issueNumber: response.data.number,
          issueUrl: response.data.html_url
        });
        
        createdCount++;
      } catch (error) {
        console.error('Error creating GitHub issue:', error.message);
        
        results.push({
          finding,
          success: false,
          error: error.message
        });
        
        errorCount++;
      }
      
      // Add a small delay between requests to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    return {
      success: true,
      results,
      summary: {
        total: limitedFindings.length,
        created: createdCount,
        duplicates: duplicateCount,
        errors: errorCount
      }
    };
  }
  
  async checkForDuplicateIssue(owner, repo, title) {
    try {
      // Search for open issues with similar titles
      const response = await this.octokit.search.issuesAndPullRequests({
        q: `repo:${owner}/${repo} is:issue is:open "${title.substring(0, 50)}"`
      });
      
      // Check if any issues have very similar titles
      return response.data.items.some(issue => {
        const similarity = this.calculateTitleSimilarity(issue.title, title);
        return similarity > 0.8; // 80% similarity threshold
      });
    } catch (error) {
      console.error('Error checking for duplicate issues:', error.message);
      return false; // Assume no duplicates if check fails
    }
  }
  
  calculateTitleSimilarity(title1, title2) {
    // Simple Jaccard similarity for titles
    const words1 = new Set(title1.toLowerCase().split(/\s+/));
    const words2 = new Set(title2.toLowerCase().split(/\s+/));
    
    const intersection = new Set([...words1].filter(word => words2.has(word)));
    const union = new Set([...words1, ...words2]);
    
    return intersection.size / union.size;
  }
  
  async getIssueStats(owner, repo) {
    const repositoryId = `${owner}/${repo}`;
    return await this.issueTracker.getIssueStats(repositoryId);
  }
}

module.exports = IssueManagementSystem;
```

## Best Practices

1. **Clear Formatting**: Create clear, well-structured issue templates
2. **Appropriate Labeling**: Apply relevant labels to help with issue organization
3. **Duplicate Detection**: Implement robust duplicate detection to avoid noise
4. **Rate Limiting**: Respect GitHub API rate limits
5. **Error Handling**: Implement robust error handling for API calls
6. **Issue Tracking**: Maintain a record of created issues for future reference
7. **Prioritization**: Focus on high-priority issues to avoid overwhelming teams

## Integration Points

The Issue Management System interfaces with:

1. **AI Analysis Coordinator**: Receives prioritized findings for issue creation
2. **Configuration Manager**: Receives settings for issue creation behavior
3. **GitHub API**: Creates and manages issues in GitHub repositories

By implementing a robust Issue Management System, the agent will be able to effectively communicate its findings to development teams through well-structured GitHub issues, enabling teams to address code quality concerns and implement suggested improvements.
